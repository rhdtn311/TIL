# 클래스

## *객체 지향 프로그래밍(OOP : Object Oriented Programming)*

소프트웨어를 개발할 때 부품에 해당하는 객체들을 먼저 만들고, 이것들을 하나씩 조립해서 완성된 프로그램을 만드는 기법을 **객체 지향 프로그래밍** 이라 한다.

<br>

### 객체(Object)

- **객체(Object)**란 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서 자신의 속성을 가지고 있고 다른 것과 식별 가능한 것을 말한다. 
- 자바는 속성을 **필드(field)**, 동작을 **메소드(method)**라고 부른다.
- 현실 세계의 객체를 소프트웨어 객체로 설계하는 것을 **객체 모델링(Object Modeling)**이라고 한다.

<br>

### 객체의 상호작용

- 객체들은 각각 독립적으로 존재하고, 다른 객체와 서로 **상호작용** 하면서 동작한다. 
- 객체들 사이의 상호작용 수단은 **메소드** 이다.
  - 객체가 다른 객체의 기능을 이용하는 것이 **메소드 호출**이다.
- 메소드 호출은 다음과 같이 객체에 도트(.) 연산자를 붙이고 메소드 이름을 기술하면 된다. 
  - 도트 연산자는 객체의 필드와 메소드에 접근할 때 사용한다.

```java
리턴값 = 객체.메소드(매개값1, 매개값2, ... )
```

- 매개 값 : 매소드를 실행하기 위해 필요한 데이터

<br>

### 객체 간의 관계

- 객체끼리의 관계는 크게 집합 관계, 사용 관계, 상속 관계가 있다.
  - **집합 관계** :하나는 부품이고 하나는 완성품에 해당
  - **사용 관계** :객체 간의 상호작용
  - **상속 관계** : 부모 객체를 기반으로 자식 객체를 생성하는 관계

<br>

### 객체 지향 프로그래밍의 특징

객체 지향 프로그램의 특징은 **캡슐화, 상속, 다형성**이 있다.

<br>

#### ***캡슐화(Encapsulation***)

- 캡슐화란 객체의 필드, 메소드를 하나로 묶고, 실제 구현 내용을 감추는 것을 말한다. 
- 자바 언어는 캡슐화된 멤버를 노출시킬 것인지, 숨길 것인지를 결정하기 위해 **접근 제한자(access Modifier)**를 사용한다.

<br>

#### ***상속(Inheritance)***

- 부모 객체가 가지고 있는 필드와 메소드를 자식 객체에게 물려주어 사용할 수 있도록 하게 해주는 것

<br>

#### ***다형성(Polymorphism)***

- 같은 타입이지만 실행 결과가 다양한 객체를 이용할 수 있는 성질

<br>

## *객체와 클래스*

메모리에서 사용하고 싶은 객체가 있다면 우선 설계도로 해당 객체를 만드는 작업이 필요하다. 자바에서는 설계도가 바로 **클래스(Class)**이다. 클래스에는 객체를 생성하기 위한 필드와 메소드가 정의되어 있다. 클래스로부터 만들어진 객체를 해당 클래스의 **인스턴스(instance)**라고 한다. 

<br>

## *클래스 선언*

클래스 이름은 다른 클래스와 식별할 목적으로 사용되므로 자바의 식별자 작성 규칙에 따라서 만들어야한다.

| 번호 | 작성규칙                                 | 예         |
| ---- | ---------------------------------------- | ---------- |
| 1    | 하나 이상의 문자로 이루어져야 한다.      | Car,Person |
| 2    | 첫 번째 글자는 숫자가 올 수 없다.        | 1Car       |
| 3    | '$','_' 외의 특수 문자는 사용할 수 없다. | #Car       |
| 4    | 자바 키워드는 사용할 수 없다.            | int, for   |

관례적으로 클래스 이름의 첫 글자는 대문자로한다. 클래스 이름을 정했다면 `"클래스이름.java"`로 소스 파일을 생성해야 한다. 생성 후 다음과 같이 클래스 선언을 한다.

```java
public class 클래스이름 {
    
}
```

두 개 이상의 클래스 선언도 가능하다.

```java
public class Car {
    
}

class Tire {
    
}
```

두 개 이상의 클래스가 선언된 소스 파일을 컴파일하면 바이트 코드 파일은 (.class) 클래스를 선언한 개수 만큼 생긴다. 즉 위 코드를 컴파일하면 `Car.class`와 `Tire,class`가 생성된다. 주의할 점은 파일 이름과 동일한 이름의 클래스 선언에만 `public` 접근 제한자를 붙일 수 있다.

<br>

## *객체 생성과 클래스 변수*

만들어진 클래스로부터 객체를 생성하는 방법은 `new` 연산자를 사용한다.

```java
new 클래스();
```

- `new`는 클래스로부터 객체를 생성시키는 연산자이다. 
- `new` 연산자 뒤에는 생성자가 오는데, 생성자는 `클래스()` 형태를 가지고 있다.
- `new` 연산자로 생성된 객체는 메모리 힙(heap) 영역에 생성된다.
  - `new` 연산자는 힙 영역에 객체를 생성시킨 후, 객체의 주소를 리턴한다.

다음은 클래스 타입으로 선언된 변수에 `new`연산자가 리턴한 객체의 주소를 저장하는 코드이다.

```java
클래스 변수;
변수 = new 클래스();

// 선언과 동시에 객체 생성
클래스 변수 = new 클래스();
```

클래스는 두 가지 용도가 있다.

1. **라이브러리 (API : Application Program Interface)**용
2. **실행용**

라이브러리 클래스는 다른 클래스에서 이용할 목적으로 설계된다. 실행 클래스는 프로그램의 실행 진입점인 `main()` 메소드를 제공하는 역할을 한다.


## *클래스의 구성 멤버*

클래스에는 객체가 가져야 할 구성 멤버가 선언된다. 구성 멤버에는 **필드(Field), 생성자(Constructor), 메소드(Method)**가 있다. 생략 및 복수 작성 가능하다.

![image](https://user-images.githubusercontent.com/68289543/104884004-f97c9000-59a8-11eb-9782-d9279f1ebd5f.png)

<br>

### 필드

- 객체의 고유 데이터, 부품 객체, 상태 정보를 저장하는 곳
- 필드는 생성자와 메소드 전체에서 사용되며 객체가 소멸되지 않는 한 객체와 함께 존재한다.

<br>

### 생성자

- 생성자는 `new` 연산자로 호출되는 중괄호 {} 블록이다.
- 생성자의 역할은 객체 생성 시 초기화를 담당한다. 
  - 필드 초기화 및 메소드를 호출해서 객체를 사용할 준비를 한다.
- 클래스 이름으로 되어 있고 리턴 타입이 없다.

<br>

### 메소드

- 메소드는 객체의 동작에 해당하는 중괄호 {} 블록을 말한다.
- 중괄호 블록은 이름을 가지고 있는데 이것이 메소드의 이름이다.
- 메소드를 호출하게 되면 중괄호 블록에 있는 모든 코드들이 일괄적으로 실행된다.
- 메소드는 객체 간의 데이터 전달의 수단으로 사용된다.
- 외부로부터 매개값을 받을 수도 있고 실행 후 값을 리턴할 수도 있다.

<br>

## 필드

필드는 객체의 고유 데이터, 객체가 가져야할 부품, 객체의 현재 상태 데이터를 저장하는 곳이다.

<br>

### *필드 선언*

필드 선언은 클래스 중괄호 {} 블록 어디서든 존재할 수 있다. 하지만 생성자와 메소드 중괄호 블록 내부에는 선언될 수 없다.

```java
타입 필드 [ = 초기값 ];
```

타입은 필드에 저장할 데이터의 종류를 말한다. (기본타입, 참조 타입) 초기 값은 선언 시 주어질 수도 있고, 생략도 가능하다.

```java
String company = "벤츠";
int maxSpeed = 100;
int currentSpeed;
boolean engineStart;
```

초기 값을 지정해주지 않는다면 객체 생성시 자동으로 필드 타입별 기본 초기 값으로 설정된다.

<br>

### *필드 사용*

필드의 사용은 필드값을 읽고, 변경하는 작업이다. 클래스 내부의 생성자나 메소드에서 사용할 경우 단순히 필드 이름으로 읽고 변경하면 되지만, 클래스 외부에서 사용할 경우 우선적으로 클래스로부터 객체를 생성한 뒤 필드를 사용해야 한다. 이유는 필드는 객체에 소속된 데이터이므로 객체가 존재하지 않는다면 필드도 존재하지 않기 때문이다.

```java
// Person 클래스

void method() {
    // Car 객체 생성
    Car myCar = new Car();
    // 필드 사용
    myCar.speed = 50;
}
```

```java
// Car 클래스

// 필드
int speed;

// 생성자
Car() {
    speed = 0;	// 값 변경
}

// 메소드
void method( ... ) {
    speed = 10;	// 값 변경
}
```

위와 같이 필드는 생성자와 모든 메소드에서 사용 가능하고, 외부 클래스(`Person`) 에서 필드 값을 변경하려면 해당 객체(`Car`)를 먼저 선언해야 한다.

<br>

## *생성자*

생성자(Constructor)는 `new` 연산자와 같이 사용되어 클래스로부터 객체를 생성할 때 호출되어 객체의 초기화를 담당한다. 생성자를 실행 시키지 않고는 클래스로부터 객체를 만들 수 없다. 

<br>

### 기본 생성자

모든 클래스는 생성자가 반드시 존재하며 , 하나 이상을 가질 수 있다. 

```java
[public] 클래스() { }
```

<br>

### 생성자 선언

기본 생성자 대신 우리가 생성자를 명시적으로 선언하려면 다음과 같은 형태로 작성하면 된다.

```java
클래스(매개변수선언, ... ) {
    // 객체의 초기화 코드
}
```

생성자는 메소드와 비슷한 모양을 가지고 있으나, 리턴 타입이 없고 클래스 이름과 동일하다.

```java
// 생성자 선언
public class Car {
    // 생성자
    Car(Stirng color, int cc) {
    }
}
```

```java
// 생성자 호출을 통한 객체 생성
public class CarExample {
    public static void main(String[] args) {
        Car myCar = new Car('black', 4000);
    }
}
```

<br>

### 필드 초기화

필드를 다른 값으로 초기화 하고 싶다면 필드를 선언할 때 값을 정해주는 방법과 생성자에서 초기값을 주는 방법이 있다.

특히, 객체 생성 시점에 외부에서 제공되는 다양한 값들로 초기화되어야 한다면 생성자에서 초기화를 해야한다.

```java
public class Korean {
    // 필드
    String nation = "대한민국";
    String name;
    String address;
    
    Korean(String n, String a) {
        name = n;
        address = a;
    }
}
```

`this`는 객체 자신을 참조하는 것을 말한다. 그래서 위 생성자 코드를 다음과 같이 바꾸어 가독성을 살릴 수 있다.

```java
public class Korean {
    // 필드
    String nation = "대한민국";
    String name;
    String address;
    
    Korean(String name, String address) {
        this.name = name;	// this.name은 Korean.name(필드)과 같다.
        this.address = address;
    }
}
```

<br>

### 생성자 오버로딩(Overloading)

생성자 오버로딩이란 매개 변수를 달리하는 생성자를 여러 개 선언하는 것을 말한다.

```java
public class 클래스 {
    클래스 ([타입 매개변수1, 타입 매개변수2, ... ]) {
        
    }
    
    클래스 ([타입 매개변수1, 타입 매개변수2, ... ]) {
     // 위 생성자와 매개 변수의 타입, 개수, 순서를 다르게 선언한다.   
    }
}
```

생성자가 오버로딩 되어있을 경우, `new`연산자로 생성자롤 호출할 때 제공되는 매개값의 타입과 수에 의해 호출될 생성자가 결정된다. 

<br>

### 다른 생성자 호출(this())

생성자 오버로딩이 많아질 경우 생성자 간의 중복된 코드가 발생할 수 있다. 그렇기 때문에 필드 초기화 내용은 한 생성자에만 집중적으로 작성하고 나머지 생성자는 초기화 내용을 가지고 있는 생성자를 호출하는 방법으로 개선할 수 있다. 생성자에서 다른 생성자를 호출할 때는 다음과 같이 `this()` 코드를 사용한다.

```java
클래스([매개변수선언, ... ]) {
    this( 매개변수, ... , 값, ... );
    실행문;
}
```

`this()`는 자신의 다른 생성자를 호출하는 코드로 반드시 생성자의 **첫 줄에서만 허용 **된다. `this()`의 매개값은 호출되는 생성자의 매개 변수 타입에 맞게 제공 되어야 한다. 

```java
Car(String model) {
    this.model = model;
    this.color = "black";
    this.maxSpeed = 100;
}

Car(String model, String color) {
    this.model = model;
    this.color = color;
    this.maxSpeed = 100;
}

Car(String model, String color, int maxSpeed) {
    this.model = model;
    this.color = color;
    this.maxSpeed = maxSpeed;
}
```

위와 같이 중복된 생성자 코드를 다음과 같이 변경할 수 있다.

```java
Car(String model) {
    this(model,"black", 100);
}

Car(String model, String color) {
    this(model, color, 100);
}

// 위 두 개의 생성자가 아래의 생성자를 호출함
Car(String model, String color, int maxSpeed) {
    this.model = model;
    this.color = color;
    this.maxSpeed = maxSpeed;
}
```

<br>

## *메소드*

메소드는 객체의 동작에 해당하는 중괄호 블록`{ }`을 말한다. 중괄호 블록의 이름이 메소드 이름이다. 메소드를 호출하게되면 중괄호 블록에 있는 모든 코드들이 일괄적으로 실행된다. 외부로부터 매개값을 받을 수 있고 실행 후 어떤 값을 리턴할 수도 있다.

<br>

### 메소드 선언

메소드 선언은 **선언부(리턴타입, 메소드이름, 매개변수선언)와 실행 블록**으로 구성된다.

```java
리턴타입 메소드이름 ([매개변수선언, ... ]) {
    실행할 코드
}
```

<br>

### 리턴 타입

- 메소드가 실행 후 리턴하는 값의 타입
- 리턴 값은 있을 수도, 없을 수도 있다.
  - 값을 반환하는 경우에는 있어야 한다.
- 리턴 값이 없는 경우에는 리턴 타입에 `void`가 와야 한다.

```java
void turnOn() { ... }
int add(int x,int y) { ... }
```

<br>


### 매개 변수 선언

매개 변수는 메소드가 실행될 때 필요한 데이터를 외부로부터 받기 위해 사용된다.

```java
double divide(int x,int y) { ... }
```

<br>

### 매개 변수의 수를 모를 경우

메소드를 선언할 때 매개 변수의 개수를 알 수 없는 경우가 있다. 이럴 때는 매개 변수를 배열 타입으로 선언하는 것이다.

```java
int sum1(int[] values) { }
```

배열의 항목 수는 호출할 때 결정된다.

```java
int values[] = {1, 2, 3};
int result = sum1(values);
int result = sum1(new int[] {1,2,3,4,5});
```

배열을 생성하지 않고 값의 리스트만 넘겨주는 방법도 있다. 바로 `...`를 사용하여 매개변수를 선언해주는 방법이다. `...`을 사용하여 매개변수를 선언한다면, 메소드 호출 시 넘겨준 값의 수에 따라 자동으로 배열이 생성되고 매개값으로 사용된다.

```java
int sum2(int ... values) { }
```

`...`으로 선언된 매개 변수 값은 다음과 같이 메소드 호출 시 리스트로 나열해주거나, 배열을 직접 매개변수로 전달해도 된다.

```java
int result = sum2(1,2,3);
int result2 = sum2(1,2,3,4,5);

int result3 = sum2(new int[] {1,2,3,4,5});
```

<br>

### 리턴(return)문

메소드 선언에 리턴 타입이 있는 메소드는 반드시 `return문`을 사용해서 리턴값을 지정해야한다. 만약 `return문`이 없다면 컴파일 오류가 발생한다. 

```java
return 리턴값;
```

<br>

### 메소드 오버로딩

클래스 내에 같은 이름의 메소드를 여러 개 선언하는 것을 **메소드 오버로딩(overloading)** 이라고 한다. 메소드 오버로딩의 조건은 매개 변수의 타입, 개수, 순서 중 하나가 달라야한다.

```java
class 클래스 {
    리턴타입 메소드이름 (타입 변수, ... ) { ... }
    
    리턴타입 메소드이름 (타입 변수, ... ) { ... }
    //무관     동일       타입,개수,순서가 달라야함
}
```

메소드 오버로딩이 필요한 이유는 매개값을 다양하게 받아 처리할 수 있도록 하기 위해서이다.

```java
int plus(int x, int y) {
    int result = x + y;
    return result;
}

int plus(double x, double y) {
    double result = x + y;
    return result;
}
```

오버로딩된 메소드를 호출할 경우 JVM은 매개값의 타입을 보고 메소드를 선택한다.

```java
plus(1,2);	// plus(int x, int y) 실행
plus(1.5, 2.3);	// double(int x, int y) 실행
```

단, JVM은 일차적으로 매개변수 타입을 보지만, 매개변수 타입이 일치하지 않은 경우 자동 타입 변환이 되는지 확인한다.

```java
plus(1, 2.5);	//double(int x, int y) 실행
```

<br>

## *인스턴스 멤버와  this*

- 인스턴스(instance) 멤버란, 객체(인스턴스)를 생성한 후 사용할 수 있는 필드와 메소드를 말한다. ( 각각, 인스턴스 필드, 인스턴스 메소드라 한다.)
- 객체 내부에서 인스턴스 멤버에 접근하기 위해 `this`를 사용할 수 있다.

<br>

## *정적 맴버와 static*

**정적 멤버 **는 클래스에 고정된 멤버로 **객체를 생성하지 않고 사용할 수 있는 필드와 메소드**를 말한다. 이들은 각각 **정적 필드, 정적 메소드**라고 부른다. 정적 멤버는 객체에 소속된 멤버가 아니라 클레스에 소속된 멤버이기 때문에 클레스 멤버라고도 한다.

<br>

### 정적 멤버 선언

필드와 메소드 선언 시 `static` 키워드를 추가적으로 붙이면 된다.

```java
public class 클래스 {
    // 정적 필드
    static 타입 필드 [= 초기값];
    
    // 정적 메소드
    static 리턴 타입 메소드( 매개변수선언, ... ) { ... }
}
```

- 정적 필드와 정적 메소드는 클래스에 고정된 멤버이므로 클래스 로더가 클래스(바이트 코드)를 로딩해서 메소드 메모리 영역에 적재할 때 클래스별로 관리된다. 따라서 클래스의 로딩이 끝나면 바로 사용할 수 있다.
- 객체마다 가지고 있어야 할 데이터 -> **인스턴스 필드**로 선언
- 공용적인 데이터 -> **정적 필드**로 선언

```java
public class Calculator {
    String color;	// 색은 다를 수 있다.
    static double pi = 3.14;	// pi의 값은 동일하다.
}
```

- 인스턴스 필드를 이용해서 실행해야 한다 -> **인스턴스 메소드**로 선언
- 인스턴스 필드를 이용하지 않는다 -> **정적 메소드**로 선언

```java
public class Calculator {
    String color;	// 인스턴스 필드
    void setColor(String color) { this.color = color; }	// 인스턴스 메소드
    static int plus(int x, int y) { return x + y; }	// 정적 메소드
    static int minus(int x, int y) { return x - y; }
}
```

<br>

### 정적 멤버 사용

클래스가 메모리로 로딩되면 정적 멤버를 사용할 수 있는데, 다음과 같이 사용한다.

```java
클래스.필드;
클래스.메소드(매게값, ... )
```

예를들어 `Calculator` 클래스를 다음과 같이 선언하였다면

```java
public class Calculator {
    static double pi = 3.14;
    static int plus(int x, int y) { return x + y; }
    static int minus(int x, int y) { return x - y; }
}
```

정적 필드 `pi`와 정적 메소드 `plus()`, `minus()`는 다음과 같이 사용할 수 있다.

```java
double result1 = 10 * 10 * Calculator.pi;
int result2 = Calculator.plus(1,2);
int result3 = Calculator.minus(5,4);
```

다음과 같이 객체 참조 변수로도 접근이 가능하다.

``` java
Calculator myCal = new Calculator;
double result1 = 10 * 10 * myCal.pi;
int result2 = myCal.plus(1,2);
int result3 = myCal.minus(5,4);
```

하지만 정적 요소는 클래스 이름으로 접근하는 것이 좋다.

<br>

### 정적 초기화 블록

정적 필드는 생성자에서 초기화 작업을 할 수 없기 때문에 자바에서는 **정적 블록(static block)**을 제공한다.

```java
static {
    ...
}
```

정적 블록은 클래스가 메모리로 로딩될 때 자동으로 실행된다. 정적 블록은 여러 개가 선언되어도 상관없다.

```java
public class Television {
    static String company = "Samsung";
    static String model = "LCD";
    static String info;
    
    static {
        info = company + "-" + model;
    }
}
```

<br>

### 정적 메소드와 블록 선언 시 주의할 점

이들은 객체가 없어도 실행되기 때문에, **이들 내부에 인스턴스 필드나 인스턴스 메소드를 사용할 수 없다.** 당연히 `this` 키워드도 사용 불가능하다. *( 인스턴스 멤버가 존재하는 시점에 클래스 멤버는 항상 존재하지만, 클래스 멤버가 존재하는 시점에 인스턴스 멤버가 존재한다는 것은 보장할 수 없기 때문이다.)*

정적 메소드와 정적 블록에서 인스턴스 멤버를 사용하고 싶다면 객체를 먼저 생성하고 참조 변수로 접근해야 한다.

```java
static void Method3() {
    ClassName obj = new ClassName();
    obj.field1 = 10;
    obj.method1();
}
```

<br>

### 싱글톤(Singleton)

- 전체 프로그램에서 단 하나의 객체만 만들도록 보장해야 하는 경우가 있다. 단 하나만 생성된다고 해서 이 객체를 **싱글톤(Singleton)**이라고 한다.
-  싱글톤을 만드려면 클래스 외부에서 `new` 연산자로 생성자를 호출할 수 없도록 막아야 한다. 
  - 생성자 앞에 `private` 접근 제한자를 붙여주면 된다.
  - 클래스 내부에서는 `new` 연산자로 생성자 호출이 가능하다.
- 자신의 타입인 **정적 필드**를 하나 선언하고 자신의 객체를 생성해 초기화한다.
  - 정적 필드도 `private` 접근 제합자를 붙여 외부에서 필드값을 변경하지 못하도록 막는다.
  - 대신 외부에서 호출할 수 있는 정적 메소드인 `getInstance()`를 선언하고 정적 필드에서 참조하고 있는 자신의 객체를 리턴해준다.

```java
public class 클래스 {
    // 정적 필드
    private static 클래스 singleton = new 클래스();
    
    // 생성자
    private 클래스() { ... };
    
    // 정적 메소드
    static 클래스 getInstance() {
        return singleton;
    }
}
```

외부에서 객체를 얻는 유일한 방법은 `getInstance()` 메소드를 호출하는 방법이다. `getInstance()` 메소드는 단 하나의 객체만 리턴하기 때문이다.

```java
// 변수1과 변수2는 동일한 객체를 참조한다.
클래스 변수1 = 클래스.getInstance();
클래스 변수2 = 클래스.getInstance();
```

<br>

## *final 필드와 상수*

### final 필드

`final` 필드는 초기값이 저장되면 이것이 최종적인 값이 되어서 프로그램 실행 도중에 수정할 수 없다.

```java
final 타입 필드 [=초기값];
```

- `final` 필드에 초기값을 줄 수 있는 방법
  1. 필드 선언 시에 주는 방법
  2. 생성자에서 주는 방법
- 생성자에서 최종적으로 `final` 필드의 초기화를 마쳐야 한다.
  - 마치지 않으면 컴파일 에러가 발생한다.

<br>

### 상수(static final)

- 불변의 값을 저장하는 필드를 **상수(constant)** 라고 한다.
- 상수는 객체마다 저장할 필요가 없는 공용성을 띄고 있으며, 여러 가지 값으로 초기화될 수 없다.
  - 즉 `static`이면서 `final`이어야 한다.
    - `static` : 객체마다 저장할 필요가 없음
    - `final` : 여러 가지 값으로 초기화될 수 없음
- **상수(static final)** 는 클래스에만 포함되어야 하고 한 번 초기값이 저장되면 변경할 수 없다.

복잡한 초기화일 경우 정적 블록에서도 할 수 있다.

```java
static final 타입 상수;
static {
    상수 = 초기값;
}
```

상수 이름은 모두 대문자로 하는 것이 관례이다. 혼합된 단어라면 언더바( _ )로 단어를 연결해준다.

```java
static final int EARTH_AGE = 100;
```

<br>

## *패키지*

- 클래스를 체계적으로 관리하기 위해 **패키지(package)** 를 사용한다.
- 폴더를 만들어 파일을 관리하듯이 패키지를 만들어 클래스를 관리한다.
- 패키지는 클래스의 일부분으로, 패키지는 클래스를 유일하게 만들어주는 식별자 역할을 한다.
  - 클래스의 이름이 같더라도 패키지의 이름이 다르면 다른 클래스로 인식한다.

```java
// 클래스 표현
상위패키지.하위패키지.클래스
```

- 클래스만 따로 복사해서 다른 곳으로 이동하면 클래스는 사용할 수 없다. 클래스를 이동할 때는 패키지 전체를 이동시켜야 한다.

<br>

### 패키지 선언

```java
// 패키지를 선언하는 방법
package 상위패키지.하위패키지;

public class ClassName { ... }
```

패키지 이름 선정에는 다음과 같은 규칙이 있다.

- 숫자로 시작하면 안되고 _, $를 제외한 특수 문자를 사용해서는 안 된다
- java로 시작하는 패키지는 자바 표준 API에서만 사용하므로 사용해서는 안 된다.
- 모두 소문자로 작성하는 것이 관례이다.

<br>

### import문

- 다른 패키지에 속하는 클래스를 사용하려면 두 가지 방법 중 하나를 선택해야한다.
  - 패키지와 클래스를 모두 기술하는 것
  - `import문` 사용 

첫 번째 방법은 패키지 명이 길어지면 코드 가독성이 떨어지기 때문에 `import문`을 사용하는 두 번째 방법을 이용한다.

```java
package com.mycompany;

// com.hankook 패키지에 있는 Tire라는 클래스를 사용
import com.hankook.Tire;
[또는 import com.hankook.*;]

public class Car {
    Tire tire = new Tire();
}
```

`import문`이 작성되는 위치는 **패키지 선언과 클래스 선언 사이**이다.

패키지에 포함된 다수의 클래스를 사용해야 한다면 클래스를 작성하지 않고 `*`을 사용해서 `import`문을 한 번 작성하면 된다.

```java
import com.hankook.*; 
```

패키지 이름 전체를 기술하는 첫 번째 방법이 필요한 경우가 있는데, 서로 다른 패키지에 동일한 클래스 이름이 존재하고, 두 패키지가 모두 `import` 되어 있을 경우이다.

<br>

## *접근 제한자*

라이브러리 클래스를 설계할 때에는 외부 클래스에서 접글할 수 있는 멤버와 접근할 수 없는 멤버로 구분해서 필드, 생성자, 메소드를 설계하는 것이 바람직하다. 자바는 이러한 기능을 구현하기 위해 **접근 제한자(Access Modifier)**를 제공하고 있다.

- 접근 제한자
  - **public** : 외부 클래스가 자유롭게 사용할 수 있는 공개 멤버를 만든다.
  - **protected** : **같은 패키지** 또는 **자식 클래스**에서 사용할 수 있는 멤버를 만든다.
  - **default** : **같은 패키지**에 소속된 클래스에서만 사용할 수 있는 멤버를 만든다.
  - **private** : 외부에 노출되지 않는 멤버를 만든다. (클래스 내부에서만 생성자를 호출할 수 있곡 객체를 만들 수 있다.)

<br>

### 클래스의 접근 제한

클래스를 선언할 때 같은 패키지 내에서만 사용할 것인지, 아니면 다른 패키지에서도 사용할 수 있도록 할 것인지를 결정해야 한다. 클래스에 적용할 수 있는 접근 제한은 `public`과 `default` 단 두 가지이다.

```java
// default 접근 제한
class 클래스 { ... }

// public 접근 제한
public class 클래스 { ... }
```

<br>

#### ***default 접근 제한***

같은 패키지에서만 사용할 수 있다.

<br>

#### ***public 접근 제한***

같은 패키지 뿐만 아니라 다른 패키지에서도 아무런 제한 없이 사용할 수 있다. 라이브러리 클래스로 개발되어야 한다면, 반드시 `public` 접근 제한을 갖도록 해야한다.

<br>

### 생성자의 접근 제한

생성자가 어떤 접근 제한을 갖느냐에 따라 호출 가능 여부가 결정된다. 생성자는 `public`, `protected`, `default`, `private` 접근 제한을 가질 수 있다.

```java
public class ClassName {
    
    // public 접근 제한
    public ClassName( ... ) { ... }
    
    // protected 접근 제한
    protected ClassName( ... ) { ... }
    
    // default 접근 제한
    ClassName( ... ) { ... }
    
    // private 접근 제한
    private ClassName( ... ) { ... }
}
```

생성자를 선언하지 않으면 자동으로 기본 생성자가 추가되는데 이 기본 생성자의 접근 제한은 클래스의 접근 제한과 동일하다.

<br>

### 필드와 메소드의 접근 제한

`public`, `protected`, `default`, `private` 접근 제한을 가질 수 있다. 위와 같다.

<br>

## *Getter와 Setter 메소드*

일반적으로 객체 지향 프로그래밍에서 객체의 데이터는 객체 외부에서 직접적으로 접근하는 것을 막는다. 그 이유는 객체의 무결성을 해칠 수 있기 때문이다. 따라서 객체 지향 프로그래밍에서는 메소드를 통해서 데이터를 변경하는 방법을 선호한다. 메소드는 매개값을 검증해서 유효한 값만 데이터로 저장할 수 있기 때문이다. 이러한 역할을 하는 메소드가 `Setter`이다.

```java
void setSpeed(double speed) {
    if(speed < 0) {
        this.speed = 0;
        return;
    } else {
        this.speed = speed;
    }
}
```

외부에서 객체의 데이터를 읽을 때도 메소드를 사용하는 것이 좋다. 객체 외부에서 객체의 필드값을 사용하기에 부적절한 경우도 있기 때문이다. 이런 경우에 메소드로 필드 값을 가공한 후 외부로 전달하면 된다. 이 때 사용하는 메소드가 `Getter`이다.

```java
double getSpeed() {
    double km = speed * 1.6;
    return km;
}
```

클래스를 선언할 때 가능하다면 필드를 `private`로 선언해서 외부로부터 보호하고, 필드에 대한 `Setter`와 `Getter` 메소드를 작성해서 필드값을 안전하게 변경/사용하는 것이 좋다. 다음은 `Setter`와 `Getter`메소드를 선언하는 방법이다.

```java
private 타입 fieldName;

// Getter
// 접근 제한자 : public, 리턴 타입 : 필드타입, 메소드 이름 : get + 필드이름, 리턴값: 필드값
public 리턴타입 getFieldName() {
    return fieldName
}

// Setter
// 접근 제한자 : public, 리턴 타입 : void, 메소드 이름 : set + 필드이름, 매개 변수 타입 : 필드타입
public void setFieldName(타입 fieldName) {
    this.fieldName = fieldName;
}

// 필드 타입이 boolean일 경우 Getter는 get으로 시작하지 않고 is로 시작하는 것이 관례이다.
```

만약 외부에서 필드값을 읽을 수만 있다면 (읽기 전용) `Getter` 메소드만 선언하거나 `Setter` 메소드를 `private` 접근 제한을 갖도록 하면된다. 

<br>
<br>
<br>




___
출처 : 한빛미디어 <이것이 자바다> 신용권





