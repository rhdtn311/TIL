## *플로이드 워셜 알고리즘 (Floyd - Warshall Algorithm)*

- **모든 지점**에서 다른 지점까지의 최단 경로를 모두 구해야 하는 경우 사용할 수 있는 알고리즘

- 단계마다 거쳐 가는 노드를 기준으로 알고리즘을 수행한다. 하지만 매번 방문하지 않은 노드 중에서 최단 거리를 갖는 노드를 찾을 필요가 없다.

- 노드의 개수가 N개 일 때 알고리즘 상으로 N번의 단계를 수행하며, 각 단계마다 O(N^2) 의 연산을 통해 **'현재 노드를 거쳐 가는'** 모든 경로를 고려한다.

  - 플로이드 워셜의 시간 복잡도 : ![image](https://user-images.githubusercontent.com/68289543/103348916-c1d3a400-4ade-11eb-8e82-0c0231333690.png)

- 2차원 리스트에 최단 거리 정보를 저장한다. 

  - 그래서 N번의 단계에서 매번 ![image](https://user-images.githubusercontent.com/68289543/103348936-cdbf6600-4ade-11eb-98d5-868be2b69cac.png) 의 시간이 소요된다.

- **다이나믹 프로그래밍**이다.

  - 노드의 개수가 N이라고 할 때, N번 만큼의 단계를 반복하며 '점화식에 맞게' 2차원 리스트를 갱신하기 때문

- 각 단계에서는 **해당 노드를 거쳐 가는 경우**를 고려한다. 

  - 예를 들어 1번 노드에 대해 확인할 때 1번 노드를 거쳐 가는 모든 경우를 고려하는 것인데 A번 -> B번 노드로 가는 것과 A번 -> 1번 -> B번 노드로 가는 것 중 더 값이 작은 경로로 갱신하는 것이다. 

- 점화식 :![image](https://user-images.githubusercontent.com/68289543/103348874-a49ed580-4ade-11eb-9482-a1e47c2e3244.png)<br> 
  a노드에서 b노드로 가는 값과 a에서 k노드를 거쳐 b노드로 가는 값 중 더 작은 값으로 갱신한다.

<br>

#### 예시

아래와 같은 그래프가 있다고 했을 때 플로이드 워셜 알고리즘을 이용하여 노드간 최단경로를 구해보자.

![K-051](https://user-images.githubusercontent.com/68289543/101638087-fb316a80-3a70-11eb-8919-a81045b1d745.png)

우선 위 노드를 통해 2차원 리스트를 만들고 연결된 값을 추가해보면 아래와 같다. (행 : 출발노드, 열 : 도착노드)

이동할 수 있으면 값을, 이동할 수 없으면 INF(무한)을 입력했다.

| 출발/ 도착 | 1번  | 2번  | 3번  | 4번  |
| ---------- | ---- | ---- | ---- | ---- |
| **1번**    | 0    | 4    | INF  | 6    |
| **2번**    | 3    | 0    | 7    | INF  |
| **3번**    | 5    | INF  | 0    | 4    |
| **4번**    | INF  | INF  | 2    | 0    |

<br>

1. **`1번 노드를 거쳐 가는 경우를 고려한다.  이 경우는 점화식을 통해 나타내면 다음과 같고 이 경우들의 값을 구하여 더 값이 작은 경우의 값으로 2차원 테이블을 갱신해주면 된다.`**

![image](https://user-images.githubusercontent.com/68289543/103349006-06f7d600-4adf-11eb-8169-59f336d2013a.png)

**`위의 여섯 가지 경우만 구하여 갱신해주면 되는데 예를들어 D24는 2번 노드에서 4번 노드로 가는 최솟값을 구하는 것인데, 2번 노드에서 4번 노드로 바로(Direct) 가는 경우의 값과 2번 노드에서 1번 노드로 이동하고 다시 1번 노드에서 4번 노드로 (2->1->4) 이동했을 경우의 값 중 더 작은 값으로 갱신해주면 된다는 뜻이다. 만약 선이 연결되어 있지 않아 이동할 수 없으면 INF(무한) 으로 표시한다. D24의 값은 (INF, 3+6=9) 중 최솟값인 9가 선택되고 9는 테이블의 2->4의 값인 INF보다 작으므로 갱신된다. 1번 노드의 경우 위의 여섯 가지 경우를 수행하면 다음과 같은 표가 완성된다.`**



| 출발/ 도착 | 1번  | 2번  | 3번  | 4번  |
| ---------- | ---- | ---- | ---- | ---- |
| **1번**    | 0    | 4    | INF  | 6    |
| **2번**    | 3    | 0    | 7    | 9    |
| **3번**    | 5    | 9    | 0    | 4    |
| **4번**    | INF  | INF  | 2    | 0    |

<br>

2. **`2번 노드를 거쳐 가는 경우도 위와 같이 수행한다. 결과는 다음과 같다.`**

| 출발/ 도착 | 1번  | 2번  | 3번  | 4번  |
| ---------- | ---- | ---- | ---- | ---- |
| **1번**    | 0    | 4    | 11   | 6    |
| **2번**    | 3    | 0    | 7    | 9    |
| **3번**    | 5    | 9    | 0    | 4    |
| **4번**    | INF  | INF  | 2    | 0    |

   <br>



3. **`3번 노드를 거쳐 가는 경우도 위와 같이 수행한다. 결과는 다음과 같다.`**

| 출발/ 도착 | 1번  | 2번  | 3번  | 4번  |
| ---------- | ---- | ---- | ---- | ---- |
| **1번**    | 0    | 4    | 11   | 6    |
| **2번**    | 3    | 0    | 7    | 9    |
| **3번**    | 5    | 9    | 0    | 4    |
| **4번**    | 7    | 11   | 2    | 0    |

<br>

4. **`4번 노드를 거쳐 가는 경우도 위와 같이 수행한다. 최종 결과는 다음과 같다.`**

| 출발/ 도착 | 1번  | 2번  | 3번  | 4번  |
| ---------- | ---- | ---- | ---- | ---- |
| **1번**    | 0    | 4    | 8    | 6    |
| **2번**    | 3    | 0    | 7    | 9    |
| **3번**    | 5    | 9    | 0    | 4    |
| **4번**    | 7    | 11   | 2    | 0    |

<br>

소스코드로 나타내면 다음과 같다.

```python
INF = int(1e9)  # 무한대를 나타내는 INF

n,m = map(int,input().split())  # n는 노드의 개수, m은 간선의 개수 
graph = [[INF] * (n + 1) for _ in range(n + 1)]  # 2차원 리스트를 모두 무한대의 값으로 초기화

# 자기 자신까지의 거리는 0으로 초기화
for a in range(1,n+1) :     
    for b in range(1,n+1) :
        if a == b :
            graph[a][b] = 0

# 간선에 대한 정보를 graph에 입력
for _ in range(m) : 
    a, b, c = map(int,input().split())
    graph[a][b] = c

# 플로이드 워셜 알고리즘 수행 k는 현재 수행중인 노드, a는 출발노드 b는 도착노드
for k in range(1, n+1) : 
    for a in range(1, n+1) : 
        for b in range(1, n+1) :
            graph[a][b] = min(graph[a][b],graph[a][k]+graph[k][b])

# 출력
for a in range(1, n+1) : 
    for b in range(1, n+1) :
        if graph[a][b] == INF : 
            print("INFINITY", end = " ")
        else : 
            print(graph[a][b], end= " ")
    print()
```

