

# 최단경로(Shortest Path)

- 가장 짧은 경로를 찾는 알고리즘으로 '길찾기 문제' 라고도 불린다.
- 최단 경로 알고리즘으로 다익스트라 알고리즘, 플로이드 워셜, 벨만 포드 알고리즘 등 다양한 알고리즘이 있다.

<br>

## *다익스트라 최단 경로 알고리즘 (Dijkstra)*

- 그래프에서 여러 노드가 있을 때, 특정한 노드에서 출발하여 다른 노드로 가는 각각의 최단 경로를 구해주는 알고리즘
- '음의 간선' 이 없을 때 정상적으로 작동한다. 
- 기본적으로 그리디 알고리즘으로 분류된다.
  - 매번 '가장 비용이 적은 노드' 를 선택해서 임의의 과정을 반복하기 때문

#### 원리

1. *출발 노드를 설정한다.*
2. *최단 거리 테이블을 초기화한다.*
3. *방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택한다.*
4. *해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신한다.*
5. *위 과정에서 3번과 4번을 반복한다.*



- 다익스트라 알고리즘은 최단 경로를 구하는 과정에서 '각 노드에 대한 현재까지의 최단 거리' 정보를 항상 1차원 리스트에 저장하며 리스트를 계속 갱신한다는 특징이 있다.



#### 예시



![K-044](https://user-images.githubusercontent.com/68289543/100999100-a937a300-359f-11eb-9b3e-b41c4a411779.png)

출발 노드를 1이라하고 1번 노드에서 다른 모든 노드로의 최단 거리를 계산한다. 초기 상태에서는 다른 모든 노드로 가는 최단 거리를 '무한' (1e9) 으로 초기화한다. 

**<br>**

1. **`먼저 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택하는데, 출발 노드에서 출발 노드로의 거리는 0이기 때문에 처음에는 출발 노드가 선택된다.`** 

| 노드 번호 | 1    | 2    | 3    | 4    | 5    | 6    |
| --------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 거리      | 0    | 무한 | 무한 | 무한 | 무한 | 무한 |

<br>

2. **`이제 1번 노드에서 다른 노드로 가는 비용을 계산한다. 1번 노드에서 2번, 3번, 4번 노드로 가는 최소 비용은 차례대로 2, 5, 1이다. 현재 테이블에서 2번, 3번, 4번 노드로 가는 최소 비용은 무한대로 표기되어 있는데 그보다 더 짧은 경로를 찾았으므로 갱신해준다.`**

![K-045](https://user-images.githubusercontent.com/68289543/101000437-43e4b180-35a1-11eb-9c7f-d282628f6a3a.png)



| 노드 번호 | 1    | 2    | 3    | 4    | 5    | 6    |
| --------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 거리      | 0    | 2    | 5    | 1    | 무한 | 무한 |

<br>

3. **`이후의 모든 단계에서도 마찬가지로 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택해야 한다. 따라서 4번 노드가 선택되고 4번 노드에서 갈 수 있는 노드인 3번과 5번 노드까지의 최단 거리를 구한다. 4번 노드는 1번 노드를 지나서 왔으므로 3번 노드까지의 최단 거리는 (1+3) 4이고, 5번 노드까지의 최단 거리는 (1+1) 2이다. 이 두 값은 기존의 리스트에 담겨 있던 값보다 작으므로 다음처럼 리스트가 갱신된다.`**

![K-046](https://user-images.githubusercontent.com/68289543/101000434-42b38480-35a1-11eb-8eed-ba727945ce36.png)

| 노드 번호 | 1    | 2    | 3    | 4    | 5    | 6    |
| --------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 거리      | 0    | 2    | 4    | 1    | 2    | 무한 |

<br>

4. **`이제 2번 노드가 선택된다. 2번과 5번 노드까지의 최단 거리가 2로 값이 같은데, 이럴 때는 일반적으로 번호가 작은 노드를 선택한다.  2번 노드를 거쳐 가는 경우, 현재의 최단 거리를 더 짧게 갱신할 수 있는 방법은 없다. (3번 노드 = 5, 4번 노드 = 2) 따라서 리스트의 어느 값도 갱신되지 않는다.`**

![K-047](https://user-images.githubusercontent.com/68289543/101000444-4515de80-35a1-11eb-8bb3-6b041d338b4c.png)

| 노드 번호 | 1    | 2    | 3    | 4    | 5    | 6    |
| --------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 거리      | 0    | 2    | 4    | 1    | 2    | 무한 |

<br>

5. **`이번에는 5번 노드가 선택된다. 5번 노드를 거쳐 3번과 6번 노드로 갈 수 있다. 3번 노드로까지의 최단 거리는 (1+1+1 = 3 ), 6번 노드로까지의 최단 거리는 (1+1+2 = 4) 이므로 두 값 모두 리스트의 최단 거리보다 작다. 따라서 모두 갱신된다.`**

![K-048](https://user-images.githubusercontent.com/68289543/101000442-447d4800-35a1-11eb-9251-b470d4dae464.png)

| 노드 번호 | 1    | 2    | 3    | 4    | 5    | 6    |
| --------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 거리      | 0    | 2    | 3    | 1    | 2    | 4    |

<br>

6. **`이어서 3번 노드를 선택하고 과정을 반복한다.`**

![K-049](https://user-images.githubusercontent.com/68289543/101000441-447d4800-35a1-11eb-9b35-479ad0e9a3ce.png)

| 노드 번호 | 1    | 2    | 3    | 4    | 5    | 6    |
| --------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 거리      | 0    | 2    | 3    | 1    | 2    | 4    |

<br>

7. **`마지막으로 6번 노드를 선택하고 과정을 반복한다.`** 

![K-050](https://user-images.githubusercontent.com/68289543/101000439-43e4b180-35a1-11eb-8bc5-f8ca7cb210c6.png)

| 노드 번호 | 1    | 2    | 3    | 4    | 5    | 6    |
| --------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 거리      | 0    | 2    | 3    | 1    | 2    | 4    |

<br>

최단 거리 테이블로 미루어 보았을 때 1번 노드에서부터 출발하여 2번, 3번, 4번, 5번, 6번 노드까지의 최단 경로는 2, 3, 1, 2, 4 이다.  다익스트라 최단 경로 알고리즘에서는 '방문하지 않은 노드 중에서 가장 최단 거리가 짧은 노드를 선택' 하는 과정을 반복하는데 이렇게 선택된 노드는 '최단 거리' 가 완전히 선택된 노드이므로, 더 이상 알고리즘을 반복해도 최단 거리가 줄어들지 않는다. 즉, 다익스트라 알고리즘이 진행되면서 **한 단계 당 하나의 노드에 대한 최단 거리를 확실히 찾는 것으로 이해할 수 있다.** 그렇기 때문에 사실상 6번 노드에 대한 최단경로를 구하는 마지막 과정은 할 필요가 없다.

<br>

### 간단한 다익스트라 알고리즘 

간단한 다익스트라 알고리즘은 **O(V^2)**(V는 노드의 개수를 의미) 의 시간복잡도를 가진다.

```python
import sys
input = sys.stdin.readline
INF = int(1e9)

n,m = map(int,input().split())		# 노드의 개수, 간선의 개수
start = int(input())		# 시작 노드 번호
graph = [[] for i in range(n+1)]	# 각 노드에 연결되어 있는 노드에 대한 정보를 담는 리스트
visited = [False] * (n+1)	# 방문한 적이 있는지 체크하는 목적의 리스트
distance = [INF] * (n+1)    # 최단 거리 테이블을 모두 무한으로 초기화

# 모든 간선의 정보를 입력받기
for _ in range(m) :
    a,b,c = map(int,input().split())	# a번 노드에서 b번 노드로 가는 비용이 c 
    graph[a].append((b,c))

# 방문하지 않은 노드 중에서, 가장 최단 거리가 짧은 노드의 번호를 반환
def get_smallest_node() : 
    min_value = INF
    index = 0    # 가장 최단 거리가 짧은 노드(인덱스)
    for i in range(1, n+1) :
        if distance[i] < min_value and not visited[i] :
            min_value = distance[i]
            index = i 
    return index

def dijkstra(start) : 
    distance[start] = 0
    visited[start] = True
    for j in graph[start] :
        distance[j[0]] = j[1]
        for i in range(n-1) :   # 시작노드를 제외한 전체 n-1 개의 노드에 대해 반복
            now = get_smallest_node()	# 현재 최단 거리가 가장 짧은 노드를 꺼내서, 방문 처리
            visited[now] = True		
            # 현재 노드와 연결된 다른 노드를 확인
        for j in graph[now] :
            cost = distance[now] + j[1]
            # 현재 노드를 거쳐서 다른 노드로 이동하는 거리가 더 짧은 경우
            if cost < distance[j[0]] : 
                distance[j[0]] = cost

dijkstra(start)		# 다익스트라 알고리즘 수행

# 모든 노드로 가기 위한 최단 거리를 출력
for i in range(1, n+1) :
    if distance[i] == INF :		# 도달할 수 없는 경우, INFINITY 라고 출력
        print("INFINITY")
    else : print (distance[i])	# 도달할 수 있는 경우 거리를 출력

```

<br>

#### 간단한 다익스트라 알고리즘의 시간 복잡도

- 시간 복잡도 : O(V^2)
  - V는 노드의 개수
  - 총 O(V) 번에 걸쳐서 최단 거리가 가장 짧은 노드를 매번 선형 탐색해야하고, 현재 노드와 연결된 노드를 매번 일일이 확인하기 때문에
  - 따라서 전체 노드의 수가 5,000개 이하라면 이 코드로 풀지만 10,000개를 넘어간다면 개선된 다익스트라 알고리즘으로 풀어야한다.

<br>

### 개선된 다익스트라 알고리즘

- 개선된 다익스트라 알고리즘의 시간 복잡도 : O(ElogV)
  - E : 간선의 개수, V : 노드의 개수
- 개선된 다익스트라 알고리즘은 힙(Heap) 자료구조를 사용한다. 
  - 최단 거리에 대한 정보를 힙에 담아서 처리하므로 더욱 빨리 찾을 수 있다.
  - 선형 시간이 아닌 로그 시간이 소요된다.

<br>

### 힙(Heap)

- 우선순위 큐(Priority Queue) 를 구현하기 위하여 사용하는 자료구조 중 하나
  - 우선순위 큐 : 우선순위가 가장 높은 데이터를 가장 먼저 삭제
  - 우선순위 값을 표현할 때는 일반적으로 정수형 자료형의 변수가 사용된다.
  - 우선순위 큐를 구현할 때는 내부적으로 **최소 힙(Min Heap)** 또는 **최대 힙(Max Heap)** 을 이용한다.
    - 최소 힙 : 값이 낮은 데이터가 먼저 삭제 ( 파이썬, 자바에서 기본 값)
    - 최대 힙 : 값이 큰 데이터가 먼저 삭제
    - 다익스트라 최단 경로 알고리즘에서는 비용이 적은 노드를 우선적으로 방문 해야하므로 최소 힙 구조를 이용한다.

<br>

#### 예시

아까와 같은 예시를 힙(Heap)을 이용하여 해결해보자.



![K-044](https://user-images.githubusercontent.com/68289543/100999100-a937a300-359f-11eb-9b3e-b41c4a411779.png)

1. **`출발 노드를 1이라하고 우선 출발 노드를 제외한 모든 노드의 최단 거리를 무한으로 설정한다. 이후에 우선순위 큐에 1번 노드를 넣는다. 거리는 0으로 설정한다. 즉, ( 거리 : 0 , 노드 : 1 ) 의 정보를 가지는 객체를 우선순위 큐에 넣는다.  파이썬에서는 (거리, 노드) 순으로 튜플을 생성하여 힙 자료구조에 집어 넣으면 첫 번째 원소인 거리를 기준으로 우선순위 큐를 구성한다.`** 

| 노드 번호 | 1    | 2    | 3    | 4    | 5    | 6    |
| --------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 거리      | 0    | 무한 | 무한 | 무한 | 무한 | 무한 |

| 우선순위 큐 | (거리 : 0, 노드: 1) |
| ----------- | ------------------- |
|             |                     |

<br>

![K-045](https://user-images.githubusercontent.com/68289543/101000437-43e4b180-35a1-11eb-9c7f-d282628f6a3a.png)

2. **`우선순위 큐를 이용하고 있으므로 거리가 가장 짧은 노드를 선택하기 위해서는 우선순위 큐에서 그냥 노드를 꺼내면 된다. 우선순위 큐에는 기본적으로 거리가 짧은 순서대로 최상위 원소로 위치하고 있기 때문에 우선순위 큐에서 노드를 꺼낸 후에 해당 노드를 이미 처리한 적이 있다면 무시하고, 처리 대상이면 처리하면 된다. 여기서 우선순위 큐에서 원소를 꺼내면 ( 0, 1 ) 이 나오는데 이는 1번 노드까지 가는 최단거리가 0이라는 의미이므로 1번 노드를 거쳐, 2번, 3번, 4번 노드로 가는 최소 비용을 계산한다. 세 노드 모두 원래 설정되어 있던 거리보다 짧으므로 테이블이 갱신되고 이렇게 더 짧은 경로를 찾은 노드 정보들은 다시 우선순위 큐에 넣는다.`**

| 노드 번호 | 1    | 2    | 3    | 4    | 5    | 6    |
| --------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 거리      | 0    | 2    | 5    | 1    | 무한 | 무한 |

| 우선순위 큐 | (거리 : 1 , 노드 : 4) (거리 : 2, 노드 : 2) (거리 : 5, 노드 : 3) |
| ----------- | ------------------------------------------------------------ |
|             |                                                              |

<br>

3. **`이어서 같은 방식으로 우선순위 큐에서 이번엔 (1,4) 를 꺼내어 동일한 과정을 반복한다.`**

![K-046](https://user-images.githubusercontent.com/68289543/101000434-42b38480-35a1-11eb-8eed-ba727945ce36.png)

| 노드 번호 | 1    | 2    | 3    | 4    | 5    | 6    |
| --------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 거리      | 0    | 2    | 4    | 1    | 2    | 무한 |

| 우선순위 큐 | (거리 : 2, 노드 : 2) (거리 : 2, 노드 : 5) (거리 : 4, 노드 : 3) (거리 : 5, 노드 : 3) |
| ----------- | ------------------------------------------------------------ |
|             |                                                              |

<br>

4. **`우선순위 큐에서 (2,2) 를 꺼내어 반복한다. 이 경우에는 테이블에 아무 변화가 일어나지 않는다.`**

![K-047](https://user-images.githubusercontent.com/68289543/101000444-4515de80-35a1-11eb-8bb3-6b041d338b4c.png)

| 노드 번호 | 1    | 2    | 3    | 4    | 5    | 6    |
| --------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 거리      | 0    | 2    | 4    | 1    | 2    | 무한 |

| 우선순위 큐 | (거리 : 2, 노드 : 5) (거리 : 4, 노드 : 3) (거리 : 5, 노드 : 3) |
| ----------- | ------------------------------------------------------------ |
|             |                                                              |

<br>

5. **`우선순위 큐에서 (2,5)를 빼내어 5번 노드에 대해 처리한다. 새로운 값이 갱신된다.`**

![K-048](https://user-images.githubusercontent.com/68289543/101000442-447d4800-35a1-11eb-9251-b470d4dae464.png)

| 노드 번호 | 1    | 2    | 3    | 4    | 5    | 6    |
| --------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 거리      | 0    | 2    | 3    | 1    | 2    | 4    |

| 우선순위 큐 | (거리 : 3, 노드 : 3) (거리 : 4, 노드 : 3) (거리 : 4, 노드 : 6) (거리 : 5, 노드 : 3) |
| ----------- | ------------------------------------------------------------ |
|             |                                                              |

<br>

6. **`이어서 원소 (3,3)을 꺼내 3번 노드를 기준으로 알고리즘을 수행한다.테이블은 갱신되지 않는다. `**

![K-049](https://user-images.githubusercontent.com/68289543/101000441-447d4800-35a1-11eb-9b35-479ad0e9a3ce.png)

| 노드 번호 | 1    | 2    | 3    | 4    | 5    | 6    |
| --------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 거리      | 0    | 2    | 3    | 1    | 2    | 4    |

| 우선순위 큐 | (거리 : 4, 노드 : 3) (거리 : 4, 노드 : 6) ( 거리 : 5, 노드 : 3) |
| ----------- | ------------------------------------------------------------ |
|             |                                                              |

<br>

7. **`이어서 원소 (4,3)을 꺼내서 3번 노드를 기준으로 알고리즘을 수행한다. 하지만 3번 노드는 앞서 처리되었는데, 우선순위 큐의 거리 값보다 테이블의 값이 더 최솟값이므로 (4 > 3) 갱신하지 않는다.`** 

| 노드 번호 | 1    | 2    | 3    | 4    | 5    | 6    |
| --------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 거리      | 0    | 2    | 3    | 1    | 2    | 4    |

| 우선순위 큐 | (거리 : 4, 노드 : 6) ( 거리 : 5, 노드 : 3) |
| ----------- | ------------------------------------------ |
|             |                                            |

<br>

8. **`이어서 원소 (4,6)이 꺼내진 후 처리한다.`**

![K-050](https://user-images.githubusercontent.com/68289543/101000439-43e4b180-35a1-11eb-8bc5-f8ca7cb210c6.png)

| 노드 번호 | 1    | 2    | 3    | 4    | 5    | 6    |
| --------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 거리      | 0    | 2    | 3    | 1    | 2    | 4    |

| 우선순위 큐 | (거리 : 5, 노드 : 3) |
| ----------- | -------------------- |
|             |                      |

<br>

9. **`마지막으로 남은 원소를 꺼내 처리한다. 다만 앞서 처리되었기 때문에 무시한다.`**

| 노드 번호 | 1    | 2    | 3    | 4    | 5    | 6    |
| --------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 거리      | 0    | 2    | 3    | 1    | 2    | 4    |

| 우선순위 큐 |      |
| ----------- | ---- |
|             |      |

<br>

- 위 방법(heap을 이용하여 최단경로를 구하는 방법)은 앞서 보여주었던 방법보다 훨씬 빠르다.
  - 파이썬에서 표준 라이브러리로 제공하는 PriorityQueue와 heapq는 데이터의 개수가 N개 일 때 **O(logN)** 의 시간복잡도를 갖는다.

``` python
import heapq
import sys
imput = sys.stdin.readline
INF = int(1e9)

n,m = map(int,input().split())	# 노드, 간선
start = int(input())	# 시작 노드
graph = [[] for i in range(n+1)]	# 노드의 연결 정보 리스트
distance = [INF] * (n+1)	# 최단 경로 값을 저장하는 테이블

for _ in range(m) :	# 간선의 정보 입력 및 graph 리스트에 저장
    a, b, c = map(int,input().split())
    graph[a].append((b,c))
    
def dijkstra(start) : 
    q = []
    # 시작 값 저장
    heapq.heappush(q, (0,start))	# q라는 heap자료구조에 (거리 : 0, 노드 : 시작노드) 값 입력
    distance[start] = 0	
    while q : # q에 데이터가 있으면
        dist, now = heapq.heappop(q)	# dist는 거리, now는 노드의 값을 저장 (거리가 min인 값)
        if  distance[now] < dist : 	# 현재 노드가 이미 처리된 적 있으면 무시
            continue
        for i in graph[now] :	# 현재 노드의 인접 노드를 확인
            cost = dist + i[1]	
            if cost < distance[i[0]]:
                distance[i[0]] = cost
                heapq.heappush(q, (cost,i[0]))
                
dijkstra(start)

for i in range(1, n+1) :
    if distance[i] == INF : 
        print("INFINITY")
    else : 
        print(distance[i])
```



#### 개선된 다익스트라 알고리즘의 시간 복잡도

- 시간 복잡도 : O(ElogV) 

<br>
<br>
참고 : 이것이 코딩테스트다 with 파이썬 (나동빈)
