# 최단경로(Shortest Path)

- 가장 짧은 경로를 찾는 알고리즘으로 '길찾기 문제' 라고도 불린다.
- 최단 경로 알고리즘으로 다익스트라 알고리즘, 플로이드 워셜, 벨만 포드 알고리즘 등 다양한 알고리즘이 있다.

<br>

## *다익스트라 최단 경로 알고리즘 (Dijkstra)*

- 그래프에서 여러 노드가 있을 때, 특정한 노드에서 출발하여 다른 노드로 가는 각각의 최단 경로를 구해주는 알고리즘
- '음의 간선' 이 없을 때 정상적으로 작동한다. 
- 기본적으로 그리디 알고리즘으로 분류된다.
  - 매번 '가장 비용이 적은 노드' 를 선택해서 임의의 과정을 반복하기 때문

#### 원리

1. *출발 노드를 설정한다.*
2. *최단 거리 테이블을 초기화한다.*
3. *방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택한다.*
4. *해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신한다.*
5. *위 과정에서 3번과 4번을 반복한다.*



- 다익스트라 알고리즘은 최단 경로를 구하는 과정에서 '각 노드에 대한 현재까지의 최단 거리' 정보를 항상 1차원 리스트에 저장하며 리스트를 계속 갱신한다는 특징이 있다.



#### 예시



![K-044](https://user-images.githubusercontent.com/68289543/100999100-a937a300-359f-11eb-9b3e-b41c4a411779.png)

출발 노드를 1이라하고 1번 노드에서 다른 모든 노드로의 최단 거리를 계산한다. 초기 상태에서는 다른 모든 노드로 가는 최단 거리를 '무한' (1e9) 으로 초기화한다. 

**<br>**

1. **`먼저 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택하는데, 출발 노드에서 출발 노드로의 거리는 0이기 때문에 처음에는 출발 노드가 선택된다.`** 

| 노드 번호 | 1    | 2    | 3    | 4    | 5    | 6    |
| --------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 거리      | 0    | 무한 | 무한 | 무한 | 무한 | 무한 |



2. **`이제 1번 노드에서 다른 노드로 가는 비용을 계산한다. 1번 노드에서 2번, 3번, 4번 노드로 가는 최소 비용은 차례대로 2, 5, 1이다. 현재 테이블에서 2번, 3번, 4번 노드로 가는 최소 비용은 무한대로 표기되어 있는데 그보다 더 짧은 경로를 찾았으므로 갱신해준다.`**

![K-045](https://user-images.githubusercontent.com/68289543/101000437-43e4b180-35a1-11eb-9c7f-d282628f6a3a.png)



| 노드 번호 | 1    | 2    | 3    | 4    | 5    | 6    |
| --------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 거리      | 0    | 2    | 5    | 1    | 무한 | 무한 |

3. **`이후의 모든 단계에서도 마찬가지로 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택해야 한다. 따라서 4번 노드가 선택되고 4번 노드에서 갈 수 있는 노드인 3번과 5번 노드까지의 최단 거리를 구한다. 4번 노드는 1번 노드를 지나서 왔으므로 3번 노드까지의 최단 거리는 (1+3) 4이고, 5번 노드까지의 최단 거리는 (1+1) 2이다. 이 두 값은 기존의 리스트에 담겨 있던 값보다 작으므로 다음처럼 리스트가 갱신된다.`**

![K-046](https://user-images.githubusercontent.com/68289543/101000434-42b38480-35a1-11eb-8eed-ba727945ce36.png)

| 노드 번호 | 1    | 2    | 3    | 4    | 5    | 6    |
| --------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 거리      | 0    | 2    | 4    | 1    | 2    | 무한 |

4. **`이제 2번 노드가 선택된다. 2번과 5번 노드까지의 최단 거리가 2로 값이 같은데, 이럴 때는 일반적으로 번호가 작은 노드를 선택한다.  2번 노드를 거쳐 가는 경우, 현재의 최단 거리를 더 짧게 갱신할 수 있는 방법은 없다. (3번 노드 = 5, 4번 노드 = 2) 따라서 리스트의 어느 값도 갱신되지 않는다.`**

![K-047](https://user-images.githubusercontent.com/68289543/101000444-4515de80-35a1-11eb-8bb3-6b041d338b4c.png)

| 노드 번호 | 1    | 2    | 3    | 4    | 5    | 6    |
| --------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 거리      | 0    | 2    | 4    | 1    | 2    | 무한 |

5. **`이번에는 5번 노드가 선택된다. 5번 노드를 거쳐 3번과 6번 노드로 갈 수 있다. 3번 노드로까지의 최단 거리는 (1+1+1 = 3 ), 6번 노드로까지의 최단 거리는 (1+1+2 = 4) 이므로 두 값 모두 리스트의 최단 거리보다 작다. 따라서 모두 갱신된다.`**

![K-048](https://user-images.githubusercontent.com/68289543/101000442-447d4800-35a1-11eb-9251-b470d4dae464.png)

| 노드 번호 | 1    | 2    | 3    | 4    | 5    | 6    |
| --------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 거리      | 0    | 2    | 3    | 1    | 2    | 4    |

6. **`이어서 3번 노드를 선택하고 과정을 반복한다.`**

![K-049](https://user-images.githubusercontent.com/68289543/101000441-447d4800-35a1-11eb-9b35-479ad0e9a3ce.png)

| 노드 번호 | 1    | 2    | 3    | 4    | 5    | 6    |
| --------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 거리      | 0    | 2    | 3    | 1    | 2    | 4    |

7. **`마지막으로 6번 노드를 선택하고 과정을 반복한다.`** 

![K-050](https://user-images.githubusercontent.com/68289543/101000439-43e4b180-35a1-11eb-8bc5-f8ca7cb210c6.png)

| 노드 번호 | 1    | 2    | 3    | 4    | 5    | 6    |
| --------- | ---- | ---- | ---- | ---- | ---- | ---- |
| 거리      | 0    | 2    | 3    | 1    | 2    | 4    |

<br>

최단 거리 테이블로 미루어 보았을 때 1번 노드에서부터 출발하여 2번, 3번, 4번, 5번, 6번 노드까지의 최단 경로는 2, 3, 1, 2, 4 이다.  다익스트라 최단 경로 알고리즘에서는 '방문하지 않은 노드 중에서 가장 최단 거리가 짧은 노드를 선택' 하는 과정을 반복하는데 이렇게 선택된 노드는 '최단 거리' 가 완전히 선택된 노드이므로, 더 이상 알고리즘을 반복해도 최단 거리가 줄어들지 않는다. 즉, 다익스트라 알고리즘이 진행되면서 **한 단계 당 하나의 노드에 대한 최단 거리를 확실히 찾는 것으로 이해할 수 있다.** 그렇기 때문에 사실상 6번 노드에 대한 최단경로를 구하는 마지막 과정은 할 필요가 없다.

<br>

#### 간단한 다익스트라 알고리즘 

간단한 다익스트라 알고리즘은 **O(V^2)**(V는 노드의 개수를 의미) 의 시간복잡도를 가진다.

```python
import sys
input = sys.stdin.readline
INF = int(1e9)

n,m = map(int,input().split())		# 노드의 개수, 간선의 개수
start = int(input())		# 시작 노드 번호
graph = [[] for i in range(n+1)]	# 각 노드에 연결되어 있는 노드에 대한 정보를 담는 리스트
visited = [False] * (n+1)	# 방문한 적이 있는지 체크하는 목적의 리스트
distance = [INF] * (n+1)    # 최단 거리 테이블을 모두 무한으로 초기화

# 모든 간선의 정보를 입력받기
for _ in range(m) :
    a,b,c = map(int,input().split())	# a번 노드에서 b번 노드로 가는 비용이 c 
    graph[a].append((b,c))

# 방문하지 않은 노드 중에서, 가장 최단 거리가 짧은 노드의 번호를 반환
def get_smallest_node() : 
    min_value = INF
    index = 0    # 가장 최단 거리가 짧은 노드(인덱스)
    for i in range(1, n+1) :
        if distance[i] < min_value and not visited[i] :
            min_value = distance[i]
            index = i 
    return index

def dijkstra(start) : 
    distance[start] = 0
    visited[start] = True
    for j in graph[start] :
        distance[j[0]] = j[1]
        for i in range(n-1) :   # 시작노드를 제외한 전체 n-1 개의 노드에 대해 반복
            now = get_smallest_node()	# 현재 최단 거리가 가장 짧은 노드를 꺼내서, 방문 처리
            visited[now] = True		
            # 현재 노드와 연결된 다른 노드를 확인
        for j in graph[now] :
            cost = distance[now] + j[1]
            # 현재 노드를 거쳐서 다른 노드로 이동하는 거리가 더 짧은 경우
            if cost < distance[j[0]] : 
                distance[j[0]] = cost

dijkstra(start)		# 다익스트라 알고리즘 수행

# 모든 노드로 가기 위한 최단 거리를 출력
for i in range(1, n+1) :
    if distance[i] == INF :		# 도달할 수 없는 경우, INFINITY 라고 출력
        print("INFINITY")
    else : print (distance[i])	# 도달할 수 있는 경우 거리를 출력

```

<br>

#### 간단한 다익스트라 알고리즘의 시간 복잡도

- 시간 복잡도 : O(V^2)
  - 총 O(V) 번에 걸쳐서 최단 거리가 가장 짧은 노드를 매번 선형 탐색해야하고, 현재 노드와 연결된 노드를 매번 일일이 확인하기 때문에
  - 따라서 전체 노드의 수가 5,000개 이하라면 이 코드로 풀지만 10,000개를 넘어간다면 개선된 다익스트라 알고리즘으로 풀어야한다.

<br>

#### 개선된 다익스트라 알고리즘

- 개선된 다익스트라 알고리즘의 시간 복잡도 : O(ElogV)
  - E : 간선의 개수, V : 노드의 개수
- 개선된 다익스트라 알고리즘은 힙(Heap) 자료구조를 사용한다. 
  - 최단 거리에 대한 정보를 힙에 담아서 처리하므로 더욱 빨리 찾을 수 있다.
  - 선형 시간이 아닌 로그 시간이 소요된다.

<br>

#### 힙(Heap)

- 우선순위 큐(Priority Queue) 를 구현하기 위하여 사용하는 자료구조 중 하나
  - 우선순위 큐 : 우선순위가 가장 높은 데이터를 가장 먼저 삭제


