## *DFS*
- 깊이 우선 탐색으로 한 노드로부터 시작하여 다음 분기로 넘어가기 전에 해당 분기를 완벽하게 탐색하는 방식
- 모든 노드를 방문하고자 할 때 사용한다.
- 검색 속도 자체는 BFS보다 느리다.
- 스택 또는 재귀함수를 이용하여 구현

## *BFS*
- 너비 우선 탐색으로 한 노드로부터 시작하여 인접한 노드를 먼저 탐색하는 탐색방법으로 시작 정점부터 가까운 정점을 먼저 방문하고 멀리 떨어져있는 정점을 나중에 방문하는 순회 방법
- 주로 두 노드 사이의 최단 경로를 찾고 싶을 때 BFS를 이용한다.
- 큐를 이용하여 구현

**![](https://lh3.googleusercontent.com/V6HkmQE0wRfXN5u4xS0H-zVmcTGMfUvrBv_eNe4GyrQ9kkhtPEKScADtWYzc7cO9-d5TQwda80WOnYf6Zm4duPgQf1S2YsrusY7ImihgEgdBzbB5-r-k_3N_RO-xVK34hL28uDyO)**
## *DFS와 BFS의 시간복잡도*
- 조건 내의 모든 노드를 검색하므로 시간복잡도는 같다.
- 다음 노드를 방문하였는지 확인하는 시간 + 각 노드를 방문하는 시간
- 인접 행렬 일 때 : O(N + E) (N은 노드, E는 간선)

  - 인접 행렬 : 2차원 배열에 각 노드가 연결된 형태를 기록하는 방식

  ``` python
  INF = 999999999
  graph = [
      [0,7,5],
      [7,0,INF],
      [5,INF,0]
  ]
  ```

- 인접 리스트 일 때 : O(N^2)

  - 인접 리스트 : 모든 노드에 연결된 노드에 대한 정보를 차례대로 연결하여 저장

  ```python
  graph = [[(1,7),(2,5)],[(0,7)],[(0,5)]]
  ```

  
 <br>
 인접행렬의 경우, 정점의 개수를 N만큼 도는 2중 for문을 돌려 두 정점 간에 간선이 존재하는 지를 확인해야 한다. 이 때, N의 제곱만큼 돌게 되므로 O(N^2)의 시간 복잡도가 된다.
 
 인접 리스트로 구현된 경우, 존재하는 간선의 정보만 저장되어 있으므로 인접 행렬에서 사용한 2중 for문이 필요하지 않는다. 다음 노드가 방문하였는지 확인할 때 간선의 개수인 E의 두 배만큼의 시간이 걸리고 (1번에서 2,6번이 방문하였는 지를 확인하고 2번에서 1,3,6번을 방문하였는지 확인한다. 이 때 1번과 2번의 간선 하나에 두 번의 확인을 하기 때문에 두 배만큼 시간이 걸린다.) 각 노드를 방문할 때 정점의 개수인 N만큼 걸린다. 따라서 O(N+2*E) = O(N+E) 가 된다.

## *DFS와 BFS에 적합한 문제*
- 그래프의 모든 정점을 방문해야 하는 문제
		- 더 편한 것을 사용
- 경로의 특징을 저장해줘야 하는 문제
		- 예를 들면 각 정점에 숫자가 적혀 있고 a부터 b까지 가는 경로를 구하는데 경로에 같은 숫자가 있으면 안된다는 문제 등, 각각의 경로마다 특징을 저장해둬야 할 때는 DFS를 사용한다. (BFS는 경로의 특징을 가지지 못한다.)
- 최단거리를 구해야 하는 문제
		- BFS를 사용
		- BFS는 가장 가까운 노드부터 차례로 검색하기 때문에 가장 먼저 찾아지는 해답이 가장 가까운 거리이다.
- 검색 대상 그래프가 매우 크다면 : DFS
- 검색 규모가 작고 검색 시작 지점부터 특정 지점까지의 거리가 짧다면 : BFS
