# 정렬 (Sorting)

정렬이란 **데이터를 특정한 기준에 따라서 순서대로 나열하는 것**으로 이진 탐색(Binary Search) 의 전처리 과정이다.

<br>

### *선택 정렬(Selection Sort)*

- 매번 가장 작은 것을 선택하는 원시적인 방법
- 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고, 그 다음 작은 데이터를 선택해 앞에서 두 번째 데이터와 바꾸는 과정

``` python
array = [4,5,8,9,6,2,1,7,3]

for i in range(len(array)) : 
    min_index = i
    for j in range(i+1,len(array)) : 
        if array[min_index] > array[j] :
            min_index = j
    array[i],array[min_index] = array[min_index],array[i]
```

<br>

#### 선택정렬의 시간복잡도

- ![image](https://user-images.githubusercontent.com/68289543/103255289-10444e00-49cc-11eb-8e17-46894a162e99.png) 
  - N-1번 만큼 가장 작은 수를 찾아서 맨 앞으로 보내야 한다.
  - 또한 매번 가장 작은 수를 찾기 위해서 비교 연산을 수행한다.
  - 소스 코드 상으로도 간단한 형태의 2중 반복문이 사용되었다.
  - 연산 횟수 : N + (N - 1) + (N - 2) + . . . + 2 => (N^2 + N) / 2 => ![image](https://user-images.githubusercontent.com/68289543/103255289-10444e00-49cc-11eb-8e17-46894a162e99.png)

- 매우 비효율적이지만 익숙해질 필요가 있다.

<br>

### *삽입 정렬(Insertion Sort)*

- 자신의 앞의 값과 크기를 비교하여 자신의 위치를 찾아 삽입하는 정렬
- 필요할 때만 위치를 바꾸므로 **데이터가 거의 정렬되어 있을 때** 훨씬 효율적
- 삽입하기 전에 그 앞까지의 데이터들은 **이미 정렬되어 있다고 가정**

<br>

예를들어 데이터가 다음과 같이 되어있다고 생각해보자.

![image](https://user-images.githubusercontent.com/68289543/103258000-da589700-49d6-11eb-99dc-4bd311f15f0d.png)

삽입 정렬은 두 번째 데이터부터 시작하고 그 앞 데이터는 이미 정렬되어 있다고 가정한다.

![image](https://user-images.githubusercontent.com/68289543/103258051-02e09100-49d7-11eb-8c8c-05be87c5bb5e.png)

따라서 위 데이터에서 4는 이미 정렬되어 있고 5부터 어느 위치로 삽입되야 하는 지 탐색하기 시작한다. 4의 왼쪽 또는 오른쪽으로 들어갈 수 있다. 5는 4보다 크니 그대로 있는다.

![image](https://user-images.githubusercontent.com/68289543/103258122-43400f00-49d7-11eb-8f9f-60eff9a6f5a9.png)

그 다음 데이터인 1이 어디에 삽입될지 판단한다. 4,5와 비교했을 때 가장 작기 때문에 4의 왼쪽에 삽입된다.

![image](https://user-images.githubusercontent.com/68289543/103258201-95813000-49d7-11eb-95b8-8bf19af5d971.png)

그 다음 데이터인 3이 어디에 삽입될지 판단한다. 5와 비교했을 때 더 작으니 위치를 바꾸고, 또 4와 비교했을 때 더 작으니 위치를 바꾸고 1과 비교했을 때 더 크니 거기서 멈춘다.

위와 같은 방법으로 삽입정렬을 총 N - 1번 진행한다. 결과적으로 모든 데이터가 정렬된다.

![image](https://user-images.githubusercontent.com/68289543/103258696-97e48980-49d9-11eb-95ec-b49653ddc680.png)

삽입정렬의 특징 중 하나는 위와 같이 정렬이 이루어진 후 원소들은 항상 오름차순을 유지하고 있다. 그렇기 때문에 삽입 되기 위하여 정렬된 데이터를 비교하는 과정에서 자신보다 작은 원소가 발견되면 그 즉시 비교를 멈추고 그 자리에 삽입된다. 그 앞의 데이터는 앞서 말했듯이 **이미 정렬 되어있고 오름차순을 유지하고 있기 때문에** 더 작을 것이기 때문이다.

<br>

```python
array = [4,5,1,3,2,8,0,9,6,7]

for i in range(1, len(array)) :
    for j in range(i, 0, -1) :
        if array[j] < array[j - 1] :
            array[j], array[j - 1] = array[j - 1], array[j]
        else : 
            break            
```

<br>

#### 삽입 정렬의 시간 복잡도

- ![image](https://user-images.githubusercontent.com/68289543/103255289-10444e00-49cc-11eb-8e17-46894a162e99.png) 
  - 반복문이 2번 중첩되어 사용
  - 최선의 경우는 ![image](https://user-images.githubusercontent.com/68289543/103261645-8c975b00-49e5-11eb-9fb6-d24649c5e4f5.png)
  - **거의 정렬되어 있는 상태**에서는 보통 가장 강력한 알고리즘이다.



<br>

### *퀵 정렬 (Quick Sort)*	

- **기준 데이터**를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 정렬 알고리즘
- **피벗**이 사용된다.
  - 피벗은 큰 데이터와 작은 데이터를 교환할 때 교환하기 위한 기준이다.
  - 퀵 정렬을 수행하기 전에는 피벗을 어떻게 설정할 것인지 미리 명시해야한다.
- 피벗을 설정하고 정렬하려는 배열의 앞에서부터 피벗보다 큰 데이터를 찾고, 뒤에서부터는 피벗보다 작은 데이터를 찾는다. 그 다음 큰 데이터와 작은 데이터의 위치를 서로 교환해주면서 정렬을 수행한다. 이 과정을 반복한다.



예를들어 자세히 설명해보면 다음과 같다.

![image](https://user-images.githubusercontent.com/68289543/103263446-447b3700-49eb-11eb-81db-a7be578da323.png)

다음과 같은 정렬되지 않은 배열이 있다고 가정해보자. 

![image](https://user-images.githubusercontent.com/68289543/103263406-28779580-49eb-11eb-8d55-ec13e6c21d94.png)

피벗은 5이고 이후에 배열의 앞부터 피벗과 비교하여 피벗보다 더 큰 데이터를 찾는다. 두 번째 원소인 7이 피벗보다 큰 데이터이므로 선택된다. 또, 배열의 뒤부터 피벗과 비교하여 피벗보다 더 작은 데이터를 찾는다. 8은 피벗보다 크고 그 다음 원소인 4가 피벗보다 작아 선택된다. 선택된 두 데이터의 위치를 바꾼다.

![image](https://user-images.githubusercontent.com/68289543/103263339-ec443500-49ea-11eb-8d99-95c9a7c24e8f.png)

그다음 위와 같이 계속 피벗보다 큰 데이터와 작은 데이터를 찾는다. 배열의 앞에서 부터는 피벗인 5보다 큰 9가, 뒤에서 부터는 피벗인 5보다 작은 2가 선택되어 서로 위치를 변경한다.

![image](https://user-images.githubusercontent.com/68289543/103263829-4f829700-49ec-11eb-843c-136386ec8aa1.png)

그다음 다시 위와 같이 피벗보다 큰 데이터와 작은 데이터를 찾는데, 왼쪽에서 부터는 피벗인 5보다 큰 원소인 6이 선택되었고, 오른쪽에서 부터는 피벗인 5보다 작은 데이터는 1이 선택되었는데 1과 6을 찾는 과정에서 서로 엇갈린 것을 볼 수 있다. 이런 경우에는 **작은데이터**와 **피벗**의 위치를 서로 변경한다.  즉, 1과 5의 위치를 서로 변경한다.

![image](https://user-images.githubusercontent.com/68289543/103264618-94a7c880-49ee-11eb-91c3-6052bd9ab02f.png)

이처럼 피벗이 이동한 후 피벗을 기준으로 왼쪽 데이터와 오른쪽 데이터를 비교해보면, 왼쪽 데이터는 피벗인 5보다 작고 오른쪽 데이터는 피벗인 5보다 크다. 이렇게 피벗을 기준으로 데이터를 위치시키는 작업을 **분할(Divide)** 혹은 **파티션(Partition)** 이라고 한다.

파티션 후, 피벗인 5를 기준으로 나뉜 왼쪽과 오른쪽의 배열들에 각각 퀵 정렬을 똑같이 수행해준다.



![image](https://user-images.githubusercontent.com/68289543/103264923-860de100-49ef-11eb-91ee-dd6afbfff719.png)

왼쪽 배열을 위와 같은 방법으로 1을 피벗으로 설정하여 정렬을 한다.

![image](https://user-images.githubusercontent.com/68289543/103264939-9a51de00-49ef-11eb-975d-ee79ff9c072c.png)

오른쪽 배열도 위와 같은 방법으로 6을 피벗으로 설정하여 정렬을 한다.

<br>

위와 같이 분할 후 퀵정렬을 또 수행해주는 과정을 반복하면 퀵정렬이 완료된다. 소스코드로 퀵 정렬을 작성할 때는 재귀 함수를 이용한다. 재귀 함수의 종료 조건은 현재 리스트의 데이터 개수가 1개인 경우이다.



```python
array = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8]

def quick_sort(array, start, end) :
    if start >= end : 
        return
    pivot = start
    left = start + 1
    right = end
    while left <= right :
        while left <= end and array[left] <= array[pivot] :
            left += 1
        while right > start and array[right] >= array[pivot] :
            right -= 1
        if left > right :
            array[right], array[pivot] = array[pivot], array[right]
        else :
            array[left], array[right] = array[right], array[left]
        
        quick_sort(array, start, right - 1)
        quick_sort(array,right + 1, end)
```

<br>

#### 퀵 정렬의 시간 복잡도

- ![image](https://user-images.githubusercontent.com/68289543/103268355-a2614c00-49f6-11eb-8bb2-aee2000d1eab.png) 
  - 평균적으로는 ![image](https://user-images.githubusercontent.com/68289543/103268355-a2614c00-49f6-11eb-8bb2-aee2000d1eab.png) 이지만 최악의 경우 ![image](https://user-images.githubusercontent.com/68289543/103268490-d6d50800-49f6-11eb-8d43-667e4ce4b7fd.png)이다.
  - 삽입 정렬과 반대로 **이미 데이터가 정렬되어 있는 경우** 매우 느리게 동작한다.

<br>

### *계수 정렬 (Count Sort)*

- 특정한 조건이 부합할 때만 사용할 수 있지만 매우 빠른 알고리즘
  - 특정한 조건 : **데이터의 크기 범위가 제한**되어 **정수 형태**로 표현할 수 있을 때
- 앞서 다루었던 정렬 알고리즘 (선택, 삽입, 퀵) 처럼 직접 데이터의 값을 비교한 뒤에 위치를 변경하는 정렬 방식이 아니다.
- 일반적으로 별도의 리스트를 선언하고 그 안에 정렬에 대한 정보를 담는다.

예를 들어 설명하면 계수 정렬은 다음과 같다.

`7 5 9 0 3 1 6 2 9 1 4 8 0 5 2`

위와 같은 데이터들을 갖는 배열이 있다고 생각해보자.



*계수정렬은 우선 가장 큰 데이터와 가장 작은 데이터의 범위가 모두 담길 수 있도록 하나의 **리스트를 생성**한다. 위 배열의 가장 작은 데이터는 0, 가장 큰 데이터는 9 이므로 0부터 9까지의 인덱스를 갖는 배열을 생성한다. 그다음 배열의 데이터들을 하나씩 확인해가면서 데이터의 값과 동일한 새로 생성한 리스트의 인덱스 값을 비교하여 값을 1씩 증가시킨다.*

<br>

배열을 담을 크기가 10인 리스트를 생성한 뒤 정렬할 배열의 데이터를 앞에서부터 차례대로 대입한다.

**7** `5 9 0 3 1 6 2 9 1 4 8 0 5 2`

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | 0    | 0    | 0    | 0    | 0    | 0    | 1    | 0    | 0    |

**7** **5** `9 0 3 1 6 2 9 1 4 8 0 5 2`

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | 0    | 0    | 0    | 0    | 1    | 0    | 1    | 0    | 0    |

**7** **5** **9**` 0 3 1 6 2 9 1 4 8 0 5 2`

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0    | 0    | 0    | 0    | 0    | 1    | 0    | 1    | 0    | 1    |

**7** **5** **9 0 3 1 6 2 9 1 4 8 0 5**` 2`

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 2    | 2    | 1    | 1    | 1    | 2    | 1    | 1    | 1    | 2    |

**7** **5** **9 0 3 1 6 2 9 1 4 8 0 5 2**

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 2    | 2    | 2    | 1    | 1    | 2    | 1    | 1    | 1    | 2    |

결과적으로 위 리스트처럼 각 데이터가 몇 번 등장했는지 그 횟수가 기록된다. 그리고 출력할 때는 리스트의 첫 번째 데이터부터 하나씩 그 값만큼 인덱스를 출력하면 된다.

```python
array = [7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2]

count = [0] * (max(array)+1)

for i in range(len(array)) :
    count[array[i]] += 1
    
for i in range(len(count)) : 
    for j in range(count[i]) : 
        print(i, end = ' ')
```

<br>

#### 계수 정렬의 시간 복잡도

- ![image](https://user-images.githubusercontent.com/68289543/103275834-61723300-4a08-11eb-8059-14e912ce1929.png) 
  - N은 데이터의 개수, K는 데이터 중 최대값의 크기
  - 앞에서부터 데이터를 하나씩 확인하면서 리스트에서 적절한 인덱스의 값을 1씩 증가시킬 뿐 아니라, 리스트의 각 인덱스에 해당하는 값들을 확인할 때 데이터 중 최대값의 크기만큼 반복 수행해야 하기 때문
- 기수 정렬과 더불어 가장 빠른 알고리즘이라 할 수 있다.

<br>

#### 계수 정렬의 공간 복잡도

- ![image](https://user-images.githubusercontent.com/68289543/103275834-61723300-4a08-11eb-8059-14e912ce1929.png) 

- 때에 따라 메모리의 비효율성을 초래할 수 있다.
  - 리스트의 데이터가 0과 1,000,000 이 존재할 때에도 크기가 1,000,001인 리스트를 선언해야 하기 때문
- 따라서 계수 정렬은 데이터의 크기가 한정되어 있고, 데이터의 크기가 많이 중복되어 있을 수록 유리하다.

<br>

<br>

___

참고 : 이것이 코딩 테스트다. with 파이썬 ( 나동빈 )
